# Массив - это основной тип данных, который представляет собой набор последовательных значений. 
# Следует знать, что массив может содержать переменные только одного типа, 
# иначе переменные будут принудительно изменены. 
# Наиболее часто употребляемая функция для создания массива - это функция c.

numbers <- c(1,4,5,2,10,15)

names <- c('R', 'Rostov', 'Ranepa')

logic <- c(1, 0, TRUE, FALSE) # числовые и логические типы переменных дружат :)

#Более сложные последовательности с помощью встроенных функций

seq(1,5, by=0.25) # задать последовательность между 1 и 5 с шагом 0.25

seq(1,2, length.out=5) #задать последовательность между 1 и 2, состоящую из 5 чисел

rep(1:3, times=3) # повторить последовательность 3 раза

rep(1:3, each=4) # повторить элемент последовательности 4 раза 

# Индексирование

numbers[1]
numbers[c(1,3,5)]

# Элементы вектора можно изменять

numbers[1] <- 10
numbers[2] <- 15
print(numbers)

# Важно! Есть также так называемая логическая индексация. 
# Например выведем все четные значения в numbers.

numbers[numbers %% 2 == 0]
#булева маска: numbers %% 2 == 0

# Длина, добавление и удаление элементов

len = length(numbers)
print(len)

numbers[len+1]

# А что, если мы захотим добавить еще элементы? Сделать это можно несколькими способами. 
# Первый - создать новый вектор, в который будет входить предыдущий
numbers2 <- c(numbers,1,2,3)
numbers2 <- c(1,2,3,numbers)

# В данном случае мы можем вставить элементы в начало или конец. 
# Если же нужно вставить элемент в определенное место, используем функцию append.
numbers <- append(numbers, -Inf, after = 3)

# Теперь удалим какой-то элемент
numbers <- numbers[-1]
print(numbers)

# Также часто нам пригодится создавать вектор из случайных чисел
# replace отвечает за то, возвращаем ли мы элемент в выборку после отбора
# Если TRUE, то у нас могут быть дублирующиеся значения, иначе не могут
random <- sample(x = 1:10, size = 5, replace=TRUE)

# Большинство арифметических операций векторизовано. 
# Это означает, что функция применяется поэлементно
vec1 <- c(1,2,3,4)
vec2 <- c(3,2,1,0)
vec1+vec2

# Что, если мы попробуем сложить 2 вектора разной длины?

1:10 + 1:2


#В подобных случаях R зацикливает, 
# то есть многократно повторяет короткий вектор до достижения длины 
# более длинного вектора. Часто на этом моменте возникают ошибки в коде, 
# поэтому если необходимо использовать зацикливание, то это следует указать 
# явно с помощью функции rep()
rep(1:2, 2)

# Матрица представляет собой двумерный массив данных. По сути, это несколько векторов, 
# которые уложены по столбцам. Создать матрицу можно с помощью функции matrix. 
# Сначала нужно передать в эту функцию вектор, который состоит из значений внутри
# матрицы, а потом задать способы ее заполнения. 
# Например, явно указать кол-во столбцов и строк.

matrix(1:4, nrow = 2, ncol = 2)
# Конечно, необязательно указывать и строки и столбцы. Достаточно указать что-то
# одно, а другое заполнится автоматически исходя из длины предоставленного в матрицу вектора.
matrix(1:4, nrow = 2)

# Если мы хотим, чтобы вектор был упакован не по столбцам, а по строкам, 
# можно воспользоваться аргументом byrow = TRUE
matrix(1:4, nrow = 2, byrow = TRUE)

#Если же нам нужна матрица какого-то определенного размера, а мы укажем вектор 
#короче этого размера, то значения просто продублируются. 
#Но лучше так не делать, потому что можно запутаться. 
#Если нужно продублировать в каком-то месте значения, укажите это явно в переданном массиве.
matrix(1:3, nrow = 2, ncol = 3, byrow = TRUE)

#У матрицы есть атрибут dim, который отвечает за ее размерность. 
#То есть он выдает кол-во строк и столбцов в матрице.
m <- matrix(1:6, nrow = 3)
dim(m)

# С матрицами работают те же правила, что и с векторами. 
#То есть большинство операций происходит поэлементно

m1 <- matrix(1:4, nrow = 2)
m2 <- matrix(c(10,20,30,40), nrow = 2)
m1 + m2
m1 - m2
m1 * m2 #поэлементо
m1 %*% m2 #по правилам линала

# Так как матрица - это двумерный массив, то и индексирование производится с 
# учетом двух размерностей.
m <- matrix(1:6, ncol = 3)
m[1,3] # выводим элемент в первой строке и в третьем столбце
m[2,] # выводим все элементы во второй строке
m[,1] # выводим все элементы в первом столбце
#Заметим, что когда мы выводим один столбец, у нас теряется размерность
m[,1, drop = FALSE] # боремся с этим с помощью drop=FALSE

# Присоединение матриц
# Две и более матриц можно соединить друг с другом. Это делается с помощью 
# функций cbind и rbind. 
# Первая присоединяет по строкам, вторая, соответственно, по столбцам.

rbind(m1,m2)
cbind(m1,m2)

# Список
#Список - это индексированная структура, элементами в котором могут быть объекты
#любого типа. Создание списков осуществляется функцией list

list(1:4, 'R_for_RANEPA', matrix(c(1,2,3), nrow = 2, ncol = 3, byrow = TRUE))
l <- list(vector = 1:4, stroka = 'R_for_RANEPA', matrix = matrix(0,2,2))
# можно давать имена каждой групппе элементов

#Индексирование в списках “двумерное”. То есть, если мы воспользуемся обычным 
#индексированием [ ], то мы получим доступ к подсписку.
l[1]
l['stroka']
#Если же мы воспользуемся индексированием с помощью [ [ ] ], 
#то получим доступ к элементу подсписка.
l[[1]] # здесь получаем доступ к массиву
#Когда мы получили доступ к нужному нам элементу, мы можем воспользоваться 
#индексированием на нем. Предположим, что нам нужно вывести 3ий элемент в 
#массиве, а массив находится в 1ом подсписке.
l[[1]][3]

# while 
day <- 1
while(day != 31){
  print(day)
  print('Зачеркиваем день')
  day <- day + 1
}

# next и break
vec <- c(1,2,3,4,5)
for( i in vec ){
  if(i == 3){
    break
  }
  print(i)
}

vec <- c(1,2,3,4,5)
for( i in vec ){
  if(i == 3){
    next
  }
  print(i)
}
